using System;
using System.Collections.Generic;
using System.Text;
using JetBrains.Annotations;

namespace Euler
{
    public static class NaturalNumbers
    {
        static void Main() { }

        /*
         * If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
         * Find the sum of all the multiples of 3 or 5 below 1000. 
         */
        public static long SumMultiplesOf3And5Under1000()
        {
            long result = 0;
            var multiplesOf3 = new HashSet<int>();
            var multiplesOf5 = new HashSet<int>();

            for (int index = 1; index < 1000; index++)
            {
                if (index % 3 == 0) { multiplesOf3.Add(index); }
                if (index % 5 == 0) { multiplesOf5.Add(index); }
            }
            multiplesOf5.UnionWith(multiplesOf3);
            var values = new int[multiplesOf5.Count];
            multiplesOf5.CopyTo(values);

            Array.ForEach(values, item => result += item);
            return result;
        }

        /*
         * Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
         * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
         * By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
         */
        public static long SumEvenFibonacciUnder4Million()
        {
            long result = 0;

            long actualValue = 0;
            int iteration = 0;
            while (actualValue < 4000000)
            {
                iteration++;
                actualValue = Fibonacci(iteration);
                if (actualValue % 2 == 0 && actualValue < 4000000) { result += actualValue; }
            }

            return result;
        }

        public static long Fibonacci(int iteration)
        {
            if (iteration <= 0) { return 0; }
            if (iteration == 1) { return 1; }
            if (iteration == 2) { return 2; }
            return Fibonacci(iteration - 2) + Fibonacci(iteration - 1);

            //round( Phi^n / √5 ) Phi = (1+√5) / 2

        }

        /*
         * The prime factors of 13195 are 5, 7, 13 and 29.
         * What is the largest prime factor of the number 600851475143 ?
         */
        public static long LargestPrimeFactorOf600851475143()
        {
            return LargestPrimeFactorOf(600851475143);
        }

        public static long LargestPrimeFactorOf(long numberToFactorize)
        {
            var allPrimesFactors = PrimesFactorsOf(numberToFactorize);
            Array.Sort(allPrimesFactors);
            return allPrimesFactors[allPrimesFactors.Length - 1];
        }

        [NotNull]
        public static long[] PrimesFactorsOf(long numberToFactorize)
        {
            var factors = new HashSet<long>();
            var sieve = 2;
            while (numberToFactorize > 1)
            {
                while (numberToFactorize % sieve == 0)
                {
                    factors.Add(sieve);
                    numberToFactorize /= sieve;
                }
                sieve = sieve + 1;
                if (sieve * sieve <= numberToFactorize) { continue; }
                if (numberToFactorize > 1) { factors.Add(numberToFactorize); }
            }

            var result = new long[factors.Count];
            factors.CopyTo(result);
            return result;
        }

        /*
         * A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
         * Find the largest palindrome made from the product of two 3-digit numbers.
         */
        public static int LargestPalindromicFromThreeDigits()
        {
            int result = 0;

            HashSet<int> potentials = new HashSet<int>();
            for (int anHundred = 1; anHundred < 10; anHundred++)
            {
                int slacker = anHundred * 100;
                while (slacker < (anHundred + 1) * 100)
                {
                    for (int index = 0; index < 100; index++)
                    {
                        int value = anHundred * 100 + index;
                        int candidate = value * slacker;
                        if (IsLongerPalindrom(candidate, result)) { potentials.Add(candidate); }

                    }
                    slacker++;
                }
            }
            int[] sortingArray = new int[potentials.Count];
            potentials.CopyTo(sortingArray);
            Array.Sort(sortingArray);
            result = sortingArray[sortingArray.Length - 1];
            return result;
        }

        public static bool IsLongerPalindrom(int candidate, int older)
        {
            string challenger = candidate.ToString();
            string champion = older.ToString();
            if (!IsAPalindrom(challenger)) { return false; }
            return challenger.Length > champion.Length;
        }

        public static bool IsAPalindrom([NotNull] string toEvaluate)
        {
            if (toEvaluate.Length % 2 != 0) { return false; }
            string left = toEvaluate.Substring(0, toEvaluate.Length / 2);

            string futureRight = toEvaluate.Substring(toEvaluate.Length / 2);
            char[] right = new char[futureRight.Length];
            futureRight.CopyTo(0, right, 0, futureRight.Length);
            Array.Reverse(right);

            for (int index = 0; index < left.Length; index++) { if (left[index] != right[index]) { return false; } }
            return true;
        }

        /*
         * 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
         * What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
         */
        public static int SmallestEvenlyDivisibleByAllTwentyFirstNumbers()
        {
            HashSet<int> factors = new HashSet<int>(new[] { 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 });

            int result = 0;
            int candidate = 2520;
            bool looping = true;
            while (looping)
            {
                if (IsEvenlyDivisibleBy(candidate, factors))
                {
                    result = candidate;
                    looping = false;
                }
                candidate++;
            }

            return result;
        }

        public static bool IsEvenlyDivisibleBy(int candidate, [NotNull] IEnumerable<int> factors)
        {
            foreach (var oneFactor in factors) { if (candidate % oneFactor != 0) { return false; } }
            return true;
        }

        /*
         * The sum of the squares of the first ten natural numbers is 1² + 2² + ... + 10² = 385 
         * The square of the sum of the first ten natural numbers is, (1 + 2 + ... + 10)² = 55² = 3025
         * Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
         * Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
         */

        public static long SumSquareDifference()
        {
            long sumAggregator = 0;
            long squareAggregator = 0;

            for (int index = 1; index < 101; index++)
            {
                sumAggregator += index;
                squareAggregator += (index * index);
            }

            sumAggregator *= sumAggregator;
            long result = Math.Abs(sumAggregator - squareAggregator);

            return result;
        }

        /*
         * By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
         * What is the 10 001st prime number?
         */

        public static ulong TenThousandOnethPrime()
        {
            var tenThousandPrimes = new[] { 1UL };
            ulong limit = (ulong)Math.Pow(2, 16);

            tenThousandPrimes = FindPrimes(limit, tenThousandPrimes);
            while (tenThousandPrimes.Length < 10001)
            {
                tenThousandPrimes = FindPrimes(limit, tenThousandPrimes);
                limit *= 2;
            }

            ulong result = tenThousandPrimes[10001];
            return result;
        }

        [NotNull]
        private static unsafe ulong[] FindPrimes(ulong limit, [NotNull] ulong[] alreadyKnownPrimes)
        {
            var tampon = new List<ulong>();
            var isPrime = new bool[limit + 1];
            var lowerLimit = Math.Sqrt(limit);
            ulong largestValue = alreadyKnownPrimes[alreadyKnownPrimes.Length - 1] > 0
                ? alreadyKnownPrimes[alreadyKnownPrimes.Length - 1]
                : 1;
            Array.Sort(alreadyKnownPrimes);

            fixed (bool* pp = isPrime)
            {
                bool* pp1 = pp;
                tampon.AddRange(Array.FindAll(alreadyKnownPrimes, item => item <= limit));
                if (limit <= largestValue) { return tampon.ToArray(); }
                for (ulong x = 1; x <= lowerLimit; x++)
                    for (ulong y = 1; y <= lowerLimit; y++)
                    {
                        var n = 4 * x * x + y * y;
                        if (n <= limit && (n % 12 == 1 || n % 12 == 5)) pp1[n] ^= true;

                        n = 3 * x * x + y * y;
                        if (n <= limit && n % 12 == 7) pp1[n] ^= true;

                        n = 3 * x * x - y * y;
                        if (x > y && n <= limit && n % 12 == 11) pp1[n] ^= true;
                    }

                for (ulong n = 5; n <= lowerLimit; n++)
                    if (pp1[n])
                    {
                        var s = n * n;
                        for (ulong k = s; k <= limit; k += s) pp1[k] = false;
                    }

                if (largestValue < 3)
                {
                    tampon.Add(2);
                    tampon.Add(3);
                }
                for (ulong n = 5; n <= limit; n += 2) if (pp1[n]) tampon.Add(n);
            }


            ulong[] sortie = new ulong[tampon.Count];
            new HashSet<ulong>(tampon).CopyTo(sortie);
            Array.Sort(sortie);
            sortie = Array.FindAll(sortie, item => item != 0);
            return sortie;
        }

        /*
         * The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
         * 
         * 73167176531330624919225119674426574742355349194934
         * 96983520312774506326239578318016984801869478851843
         * 85861560789112949495459501737958331952853208805511
         * 12540698747158523863050715693290963295227443043557
         * 66896648950445244523161731856403098711121722383113
         * 62229893423380308135336276614282806444486645238749
         * 30358907296290491560440772390713810515859307960866
         * 70172427121883998797908792274921901699720888093776
         * 65727333001053367881220235421809751254540594752243
         * 52584907711670556013604839586446706324415722155397
         * 53697817977846174064955149290862569321978468622482
         * 83972241375657056057490261407972968652414535100474
         * 82166370484403199890008895243450658541227588666881
         * 16427171479924442928230863465674813919123162824586
         * 17866458359124566529476545682848912883142607690042
         * 24219022671055626321111109370544217506941658960408
         * 07198403850962455444362981230987879927244284909188
         * 84580156166097919133875499200524063689912560717606
         * 05886116467109405077541002256983155200055935729725
         * 71636269561882670428252483600823257530420752963450
         * 
         * Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
         */
        public static long GreatestAdjacentSerieInBigDigit()
        {

            var bigDigitBuilder = new StringBuilder();
            bigDigitBuilder.Append("73167176531330624919225119674426574742355349194934");
            bigDigitBuilder.Append("96983520312774506326239578318016984801869478851843");
            bigDigitBuilder.Append("85861560789112949495459501737958331952853208805511");
            bigDigitBuilder.Append("12540698747158523863050715693290963295227443043557");
            bigDigitBuilder.Append("66896648950445244523161731856403098711121722383113");
            bigDigitBuilder.Append("62229893423380308135336276614282806444486645238749");
            bigDigitBuilder.Append("30358907296290491560440772390713810515859307960866");
            bigDigitBuilder.Append("70172427121883998797908792274921901699720888093776");
            bigDigitBuilder.Append("65727333001053367881220235421809751254540594752243");
            bigDigitBuilder.Append("52584907711670556013604839586446706324415722155397");
            bigDigitBuilder.Append("53697817977846174064955149290862569321978468622482");
            bigDigitBuilder.Append("83972241375657056057490261407972968652414535100474");
            bigDigitBuilder.Append("82166370484403199890008895243450658541227588666881");
            bigDigitBuilder.Append("16427171479924442928230863465674813919123162824586");
            bigDigitBuilder.Append("17866458359124566529476545682848912883142607690042");
            bigDigitBuilder.Append("24219022671055626321111109370544217506941658960408");
            bigDigitBuilder.Append("07198403850962455444362981230987879927244284909188");
            bigDigitBuilder.Append("84580156166097919133875499200524063689912560717606");
            bigDigitBuilder.Append("05886116467109405077541002256983155200055935729725");
            bigDigitBuilder.Append("71636269561882670428252483600823257530420752963450");

            var bigDigit = bigDigitBuilder.ToString();

            int lengthOfWindow = 13;

            string textWindow = bigDigit.Substring(0, lengthOfWindow);
            long sumOfWindow = 1;
            long bestSum = sumOfWindow;
            int barrier = bigDigit.Length - lengthOfWindow;
            int index = 0;

            while (index < barrier)
            {
                foreach (char t in textWindow) { sumOfWindow *= int.Parse(t.ToString()); }
                if (sumOfWindow > bestSum)
                {
                    bestSum = sumOfWindow;
                }
                index++;
                textWindow = bigDigit.Substring(index, lengthOfWindow);
                sumOfWindow = 1;
            }

            return bestSum;
        }

        /*
         * A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
         * a² + b² = c²
         * For example, 3² + 4² = 9 + 16 = 25 = 5².
         * There exists exactly one Pythagorean triplet for which a + b + c = 1000.
         * Find the product abc.
         */
        public static long SpecialPythagoreanTriplet()
        {
            for (int prem = 0; prem < 1000; prem++)
            {
                for (int deux = 0; deux < 1000; deux++)
                {
                    for (int trio = 0; trio < 1000; trio++)
                    {
                        if (!(prem < deux && deux < trio)) { continue; }
                        if (prem + deux + trio != 1000) { continue; }
                        if (IsAPythagoreanTriplet(prem, deux, trio)) { return prem * deux * trio; }
                    }
                }
            }
            return 0;
        }

        public static bool IsAPythagoreanTriplet(int prem, int deux, int trio)
        {
            var first = prem * prem;
            var second = deux * deux;
            var third = trio * trio;
            if (first + second == third) { return true; }
            return false;
        }
    }

}